<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"1000charsdance.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="chardance的博客">
<meta property="og:url" content="https://1000charsdance.github.io/page/2/index.html">
<meta property="og:site_name" content="chardance的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chardance">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://1000charsdance.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>chardance的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">chardance的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2022/10/22/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">计算机问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-22T00:00:00+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:51:43" itemprop="dateModified" datetime="2024-05-01T10:51:43+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、memmove和strcpy的区别"><a href="#1、memmove和strcpy的区别" class="headerlink" title="1、memmove和strcpy的区别"></a>1、memmove和strcpy的区别</h3><p>举例：MIT6.S081中Lab1的find练习，有个地方不能用memmove，能用strcpy。</p>
<p>状态：未解决</p>
<h3 id="2、MIT6-S828-Lab1-pingpong"><a href="#2、MIT6-S828-Lab1-pingpong" class="headerlink" title="2、MIT6.S828 Lab1 pingpong"></a>2、MIT6.S828 Lab1 pingpong</h3><p>时间：2022、9、4</p>
<p>状态：未解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p[2]: pipe</span></span><br><span class="line"><span class="comment">// n: a prime</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// guard</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);</span><br><span class="line">	<span class="type">int</span> *buf = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// create pipe</span></span><br><span class="line">	<span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">	pipe(p1);</span><br><span class="line">	<span class="keyword">while</span> (read(p[<span class="number">0</span>], buf, <span class="number">4</span>) != <span class="number">0</span> &amp;&amp; *buf % n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/* do nothing */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a = *buf;</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">		close(p1[<span class="number">1</span>]);</span><br><span class="line">		func(p1, a);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// parent process</span></span><br><span class="line">		close(p1[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span> (read(p[<span class="number">0</span>], buf, <span class="number">4</span>) != <span class="number">0</span> &amp;&amp; *buf != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*buf % n != <span class="number">0</span>)</span><br><span class="line">				write(p1[<span class="number">1</span>], buf, <span class="number">4</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		*buf = <span class="number">-1</span>;</span><br><span class="line">		write(p1[<span class="number">1</span>], buf, <span class="number">4</span>);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	pipe(p);</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">		close(p[<span class="number">1</span>]);</span><br><span class="line">		func(p, <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// parent process</span></span><br><span class="line">		close(p[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; <span class="number">36</span>; ++i) &#123;</span><br><span class="line">			write(p[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">-1</span>;</span><br><span class="line">		write(p[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">close() 关闭文件描述符</span></span><br><span class="line"><span class="comment">定义、使用递归函数sieiv</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受父进程的输入，进行筛选</span></span><br><span class="line"><span class="comment">// pleft：父进程到子进程的管道</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sieve</span><span class="params">(<span class="type">int</span> pleft[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    read(pleft[<span class="number">0</span>], &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 哨兵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pright[<span class="number">2</span>];</span><br><span class="line">    pipe(pright);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        close(pright[<span class="number">1</span>]); <span class="comment">// 子进程不需要向父进程写数据</span></span><br><span class="line">        sieve(pright);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        close(pright[<span class="number">0</span>]); <span class="comment">// 不读子进程</span></span><br><span class="line">        <span class="type">int</span> buf;</span><br><span class="line">        <span class="keyword">while</span> (read(pleft[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(buf)) &amp;&amp; buf != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf % p != <span class="number">0</span>) write(pright[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="number">-1</span>;</span><br><span class="line">        write(pright[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    pipe(input_pipe);</span><br><span class="line">    <span class="type">int</span> p = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        close(input_pipe[<span class="number">1</span>]); <span class="comment">// 不向子进程写</span></span><br><span class="line">        sieve(input_pipe); <span class="comment">// 接受父进程的输入，进行筛选</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        close(input_pipe[<span class="number">0</span>]); <span class="comment">// 不读子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">2</span>; p &lt; <span class="number">36</span>; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(input_pipe[<span class="number">1</span>], &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">-1</span>; <span class="comment">// 结束标志</span></span><br><span class="line">        write(input_pipe[<span class="number">1</span>], &amp;p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、c-读写中文、字符、字符集（locale、codecvt）"><a href="#3、c-读写中文、字符、字符集（locale、codecvt）" class="headerlink" title="3、c++读写中文、字符、字符集（locale、codecvt）"></a>3、c++读写中文、字符、字符集（locale、codecvt）</h3><p>wchar：16位（window）、32位（unix-like）</p>
<p>char8（c++20）、char16、char32：unicode字符集的三种编码</p>
<p><strong>使用locale设置本地语言</strong></p>
<p>使用reinterpret_cast将char8转换成char&amp;，将char16和char32转换成wchar（视平台而定）</p>
<p>原文：</p>
<p>C++20 的正确处置办法就是</p>
<ol>
<li>（老生常谈）正确性很重要，编码转换省不得。<locale>、平台 API、boost.locale、ICU 都可以帮你。</locale></li>
<li>内部尽量用 Unicode。Unicode 编码应作为中间格式。表达文本的字符串的字面量应当用 Unicode 版本，且源文件应以 Unicode 编码保存，否则可能因编辑器、编译器、其它系统（例如拷源码到别的机器上）的编码设置不一致导致乱码。</li>
<li>（现实考量）Linux 上的 wcin&#x2F;wcout 破烂不堪，从来没有靠谱过。Windows API 以 USC2（美其名曰 UTF-16） 为本，用 cin&#x2F;cout 虽然有性能损失，但为了跨平台迁就 Linux，还是选用 cin&#x2F;cout 较好。（坚实可靠 Windows 支持 cin&#x2F;cout 和 wcin&#x2F;wcout 混用，但其他系统不一定。）</li>
<li>locale 可以设置为 Unicode 变体。此时 std::cout 的 char 的编码是 UTF-8。而 std::wcout 的 char 的编码是 UTF-8，wchar_t 编码是 UTF-16（Windows）或 UTF-32（多数 Unix-like）。这样，char8_t &amp; 在输入&#x2F;输出能 reinterpret_cast 成 char &amp;，而 char16_t &amp; 或 char32_t &amp; 中的一种（视平台而定）可以 reinterpret_cast 成 wchar_t &amp;。string&#x2F;u8string&#x2F;u16string&#x2F;u32string 同理处置。这样能解决大多数需求。</li>
<li>Language lawyers 先别激动。<strong>更正确的方法当然是用 std::codecvt 等编码转换功能来转换。</strong></li>
<li>string 间的转换和重载好的运算符，标准库虽未提供，但你可以自行添加。未来可能标准库可能会添加一部分。</li>
</ol>
<p>std::codecvt 的取得：</p>
<ol>
<li>std::codecvt&lt;char16_t, char8_t, std::mbstate_t&gt;、std::codecvt&lt;char32_t, char8_t, std::mbstate_t&gt; 和 std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; 直接由 <locale> 提供，可以放心使用。std::codecvt&lt;char16_t, char, std::mbstate_t&gt; 其实等同于 std::codecvt&lt;char16_t, char8_t, std::mbstate_t&gt;，并不是真的转换到特定编码的 char，已被 C++20 废止。其他 std::codecvt_u??? 也是同理，均已废止。（std::codecvt_byname 各模板实例的情况与 std::codecvt 的平行，不再赘述。）</locale></li>
<li>其他 std::codecvt 通过 use_facet&lt;codecvt&lt;TChar1, TChar2, mbstate_t&gt;&gt;(locale) 取得，标准库不保证各种 char 之间的转换都已实现。你可用使用 boost.locale 补充。</li>
</ol>
<p>C++20 中，C++ 风格 API 不提供独立的 Unicode 和非 Unicode 之间的转换。但 C 风格 API mbrtoc16&#x2F;c16rtomb&#x2F;c16rtomb&#x2F;mbrtoc32&#x2F;c32rtomb&#x2F;mbsrtowcs&#x2F;wcsrtombs 包含此类转换，但其中 char&#x2F;wchar_t 编码依赖具体实现&#x2F;平台和设置，请小心使用。libiconv 提供更多更好用的 C API。</p>
<h3 id="4、c-读文件省略空白符（空格和换行）noskipws"><a href="#4、c-读文件省略空白符（空格和换行）noskipws" class="headerlink" title="4、c++读文件省略空白符（空格和换行）noskipws"></a>4、c++读文件省略空白符（空格和换行）noskipws</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(......)</span></span>;</span><br><span class="line">ifs &gt;&gt; noskipws; <span class="comment">// 不省略空白符</span></span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">peek</span>() != EOF)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">ifs &gt;&gt; skipws <span class="comment">// 恢复默认省略空白符</span></span><br></pre></td></tr></table></figure>

<h3 id="5、c-读文件结尾判读不用eof-。原因：文件指针。"><a href="#5、c-读文件结尾判读不用eof-。原因：文件指针。" class="headerlink" title="5、c++读文件结尾判读不用eof()。原因：文件指针。"></a>5、c++读文件结尾判读不用eof()。原因：文件指针。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(......)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">peek</span>() != EOF) <span class="comment">// 不用 while(!ifs.eof()) &#123; &#125;</span></span><br><span class="line">&#123;						 <span class="comment">// 文件指针移动的问题</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、空字符串””的长度为1，其实没有内容，不必理会"><a href="#6、空字符串””的长度为1，其实没有内容，不必理会" class="headerlink" title="6、空字符串””的长度为1，其实没有内容，不必理会"></a>6、空字符串””的长度为1，其实没有内容，不必理会</h3><h3 id="7、error-LNK2005-已在-obj中定义-全局定义"><a href="#7、error-LNK2005-已在-obj中定义-全局定义" class="headerlink" title="7、error LNK2005 已在.obj中定义 全局定义"></a>7、error LNK2005 已在.obj中定义 全局定义</h3><h4 id="全局变量定义"><a href="#全局变量定义" class="headerlink" title="全局变量定义"></a>全局变量定义</h4><p>在.h中声明，全局变量在.cpp中定义，在需要该全局变量的.cpp文件中使用extern声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">/* do something with a */</span></span><br><span class="line"><span class="comment">// end b.cpp</span></span><br></pre></td></tr></table></figure>

<h4 id="全局常量定义"><a href="#全局常量定义" class="headerlink" title="全局常量定义"></a>全局常量定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> global;  <span class="comment">// 仅声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> global = <span class="number">0</span>;  <span class="comment">// 定义 extern和初始化不同时出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line">cout &lt;&lt; global &lt;&lt; endl;   <span class="comment">// 声明后即可使用</span></span><br></pre></td></tr></table></figure>

<h3 id="8、warning-4819"><a href="#8、warning-4819" class="headerlink" title="8、warning 4819"></a>8、warning 4819</h3><h4 id="vscode-cmakelists-txt"><a href="#vscode-cmakelists-txt" class="headerlink" title="vscode cmakelists.txt"></a>vscode cmakelists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line"></span><br><span class="line">  \<span class="comment"># 设置 msvc 输入代码编码格式为 utf-8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(CMAKE_C_FLAGS /source-charset:utf-<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="9、c-转义字符的文件读取"><a href="#9、c-转义字符的文件读取" class="headerlink" title="9、c++转义字符的文件读取"></a>9、c++转义字符的文件读取</h3><p>文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>读取出来变成两个字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\\&#x27;</span> 和 <span class="string">&#x27;\&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不解决</p>
<h3 id="10、map第26个位置或-026写入文件后读取出来，导致后续读取文件失败"><a href="#10、map第26个位置或-026写入文件后读取出来，导致后续读取文件失败" class="headerlink" title="10、map第26个位置或\026写入文件后读取出来，导致后续读取文件失败"></a>10、map第26个位置或\026写入文件后读取出来，导致后续读取文件失败</h3><p>\026表示ctrl + z，当从文件读取该字节时，效果等同于从键盘输入ctrl + z。</p>
<h3 id="11、C-ifstream打开文件ios-in模式和ios-binary模式，std-getline-函数危险！文本、二进制不同角度"><a href="#11、C-ifstream打开文件ios-in模式和ios-binary模式，std-getline-函数危险！文本、二进制不同角度" class="headerlink" title="11、C++ifstream打开文件ios::in模式和ios::binary模式，std::getline()函数危险！文本、二进制不同角度"></a>11、C++ifstream打开文件ios::in模式和ios::binary模式，std::getline()函数危险！文本、二进制不同角度</h3><p>与第10条相同原因。</p>
<p>in模式打开文件，其实是以文本形式打开文件，binary模式则是二进制形式。</p>
<p>文本形式下，从文件读入时默认省略空白符，使用std::noskipws更改，同第4条。</p>
<p>std::getline()是文本角度的函数，遇到\10即\n即停止，不适用在二进制的问题（如编码）。</p>
<h3 id="12、Qt使用ifstream打开中文路径失败。"><a href="#12、Qt使用ifstream打开中文路径失败。" class="headerlink" title="12、Qt使用ifstream打开中文路径失败。"></a>12、Qt使用ifstream打开中文路径失败。</h3><p>中文路径参数为gbk2312编码时，ifstream的open函数的时能够正常运行。</p>
<p>一种成功的解决方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">MainWindow::utf8ToGb2312</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *strUtf8)</span></span>;</span><br><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">MainWindow::utf8ToGb2312</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *strUtf8)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextCodec* utf8Codec= QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    QTextCodec* gb2312Codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QString strUnicode= utf8Codec -&gt;<span class="built_in">toUnicode</span>(strUtf8);</span><br><span class="line">    QByteArray ByteGb2312= gb2312Codec -&gt;<span class="built_in">fromUnicode</span>(strUnicode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ByteGb2312.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、qt程序崩溃处理"><a href="#13、qt程序崩溃处理" class="headerlink" title="13、qt程序崩溃处理"></a>13、qt程序崩溃处理</h3><p>1、使用qDebug()慢慢找</p>
<p>2、使用调式模式设置断点</p>
<p>3、使用dump和pdb找到出错的一行代码，这个一开始弄起来比较麻烦，弄好了之后比较方便，编译器使用MSVC，不能用MinGW，一般结合vs或者Windbg。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a844651990/article/details/85225273">Qt-生成dump文件_qt dump_FlyWM_的博客-CSDN博客</a>好像很好</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1930512">QT应用编程: window下QT程序异常捕获并生成DMP文件、PDB文件-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyhse/article/details/112533333">Windows下Qt生成dump文件并定位bug（基于qBreakpad）_百里杨的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39376945">QTest单元测试框架，简单，好用，高效 - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2022/10/22/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E5%A4%A7%E4%B8%89%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B/" class="post-title-link" itemprop="url">大三算法设计课程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-22T00:00:00+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:53:05" itemprop="dateModified" datetime="2024-05-01T10:53:05+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="统计区间长度"><a href="#统计区间长度" class="headerlink" title="统计区间长度"></a>统计区间长度</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>空间开销较大</p>
<h4 id="线段树的数据结构"><a href="#线段树的数据结构" class="headerlink" title="线段树的数据结构"></a>线段树的数据结构</h4><ol>
<li>动态数据结构</li>
<li>完全二叉树</li>
</ol>
<p>1 1</p>
<p>0 1 3 4 1 3</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>#include <queue></queue></p>
<p>push()     插入元素到队尾 (并排序)<br>pop()      弹出队头元素(自动调整)<br>top()       访问队头元素<br>empty()    队列是否为空<br>size()      返回队列内元素个数<br>emplace()  原地构造一个元素并插入队列<br>swap()      交换内容</p>
<p>priority_queue&lt;type,vector<type>,comp&gt;Q;</type></p>
<p>第一个参数type是数据类型<br>第二个是容器类型，STL默认容器是vector<br>第三comp个是比较函数，如果没有此参数，默认大根堆，即降序排列  </p>
<p>priority_queue&lt;int,vector<int> &gt;T;<em>&#x2F;&#x2F;这里注意要多打一个空格</em></int></p>
<p>priority_queue&lt;int,vector<int>,greater<int> &gt;T;<em>&#x2F;&#x2F;小根堆</em></int></int></p>
<p>priority_queue<NODE> q; &#x2F;&#x2F; 小根堆（按时间排列）<br>&#x2F;&#x2F; 小根堆（按时间排列）<br>bool operator&lt;(const NODE&amp; lhs, const NODE&amp; rhs)<br>{<br>    return rhs.time &lt; lhs.time;<br>}</NODE></p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="ZOJ1091"><a href="#ZOJ1091" class="headerlink" title="ZOJ1091"></a>ZOJ1091</h2><p>1步走到填1，2步走到填2，用弗洛依德算法求最短路径，用无相图表示。三重循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i</span><br><span class="line">    <span class="keyword">for</span> j</span><br><span class="line">        <span class="keyword">for</span> k</span><br><span class="line">            xxx</span><br></pre></td></tr></table></figure>

<h2 id="zoj2770"><a href="#zoj2770" class="headerlink" title="zoj2770"></a>zoj2770</h2><p>解题思路：输入刘备的阵营信息，要求输出刘备最少拥有多少人，如果无法估计，输出”Bad Estimations”。</p>
<p>x1+x2&gt;&#x3D;1100</p>
<p>x2+x3&gt;&#x3D;1300</p>
<p>x1&lt;&#x3D;1000</p>
<p>x2&lt;&#x3D;2000</p>
<p>x3&lt;&#x3D;1000</p>
<p>求x1+x2+x3的最小值</p>
<p>1100&lt;&#x3D;x1+x2</p>
<p>1300&lt;&#x3D;x2+x3</p>
<h2 id="zoj1137"><a href="#zoj1137" class="headerlink" title="zoj1137"></a>zoj1137</h2><h3 id="二部图"><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h3><p><img src="https://img-blog.csdnimg.cn/20190609121130545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODIyMDI5,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="完全二部图"><a href="#完全二部图" class="headerlink" title="完全二部图"></a>完全二部图</h3><p>上图（5）</p>
<h3 id="边独立集"><a href="#边独立集" class="headerlink" title="边独立集"></a>边独立集</h3><h3 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h3><p>边数最多</p>
<h3 id="完备（完美-x2F-完全）匹配"><a href="#完备（完美-x2F-完全）匹配" class="headerlink" title="完备（完美&#x2F;完全）匹配"></a>完备（完美&#x2F;完全）匹配</h3><p>用0.5n条边包含n个顶点</p>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p>最小边覆盖 &#x3D; n - 最大匹配</p>
<h3 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h3><h2 id="zoj-2451"><a href="#zoj-2451" class="headerlink" title="zoj 2451"></a>zoj 2451</h2><h3 id="线段树-1"><a href="#线段树-1" class="headerlink" title="线段树"></a>线段树</h3><p>把连续的线段离散化，使得计算机能够计算</p>
<h3 id="如何离散化"><a href="#如何离散化" class="headerlink" title="如何离散化"></a>如何离散化</h3><h4 id="点枚举方法"><a href="#点枚举方法" class="headerlink" title="点枚举方法"></a>点枚举方法</h4><h4 id="线段离散化"><a href="#线段离散化" class="headerlink" title="线段离散化"></a>线段离散化</h4><p>把一条线段看成一个或几个点，再运用上一种方法，线段较少时有效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2022/01/05/English/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/05/English/" class="post-title-link" itemprop="url">English</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-05 09:14:58" itemprop="dateCreated datePublished" datetime="2022-01-05T09:14:58+08:00">2022-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-06 19:29:28" itemprop="dateModified" datetime="2022-01-06T19:29:28+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h2><h3 id="2022-x2F-1-x2F-5"><a href="#2022-x2F-1-x2F-5" class="headerlink" title="2022&#x2F;1&#x2F;5"></a>2022&#x2F;1&#x2F;5</h3><h4 id="let-down"><a href="#let-down" class="headerlink" title="let down"></a>let down</h4><p>to disappoint sb.</p>
<p>e.g. Don’t let me down. And I won’t let you down.</p>
<h4 id="⭐go-to-some-x2F-any-x2F-such-x2F-great-lengths-to-do-sth"><a href="#⭐go-to-some-x2F-any-x2F-such-x2F-great-lengths-to-do-sth" class="headerlink" title="⭐go to some&#x2F;any&#x2F;such&#x2F;great lengths (to do sth.)"></a>⭐go to some&#x2F;any&#x2F;such&#x2F;great lengths (to do sth.)</h4><p>to try vary hard or to do anything necessary (to achieve something)</p>
<p>e.g. Thank you for going to such lengths to help me.</p>
<h4 id="⭐go-about"><a href="#⭐go-about" class="headerlink" title="⭐go about"></a>⭐go about</h4><p>to work at something</p>
<p>e.g. Despite the threat of war, people went about their work as usual.</p>
<h4 id="⭐put-sth-across-to-sb"><a href="#⭐put-sth-across-to-sb" class="headerlink" title="⭐put sth. across to sb."></a>⭐put sth. across to sb.</h4><p>too communicate or convey one’s personality, an idea, etc. to somebody</p>
<p>e.g. She’s good at putting her ideas across to her workmates.</p>
<p>e.g. It’s much more important to put your ideas to your workmates than just do your work well.</p>
<h4 id="stand-out"><a href="#stand-out" class="headerlink" title="stand out"></a>stand out</h4><p>to be easily seen; to be clearly much better than the rest</p>
<p>e.g. She stands out as the best poet of her generation.</p>
<h4 id="turn-around"><a href="#turn-around" class="headerlink" title="turn around"></a>turn around</h4><p>to reverse the direction of sb. or sth.</p>
<p>e.g. The company was losing money and they hired a new president to turn it around.</p>
<h4 id="stick-with"><a href="#stick-with" class="headerlink" title="stick with"></a>stick with</h4><p>to continue to support or retain one’s connection with sb. or sth.</p>
<p>e.g. At first, he had trouble with his job, but he stuck with it and is now doing well.</p>
<h4 id="at-work"><a href="#at-work" class="headerlink" title="at work"></a>at work</h4><p>having an effect; operating</p>
<p>e.g. She suspected that secret influences were at work.</p>
<h4 id="keep-one’s-word"><a href="#keep-one’s-word" class="headerlink" title="keep one’s word"></a>keep one’s word</h4><p>to do what one has promised</p>
<p>e.g. He promised her he’d give up drinking, but he failed to keep his word.</p>
<h4 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h4><p>You have promised me that you would go to any length to turn your terrible life around. Even if you seem to not stand out, going about what you dream to do must be at work. Keep your word and stick with it, don’t let me down and don’t let yourself down. If you have any trouble, feel free to put it to me and I will help you without hesitation. You have my word.</p>
<h3 id="2022-x2F-1-x2F-6"><a href="#2022-x2F-1-x2F-6" class="headerlink" title="2022&#x2F;1&#x2F;6"></a>2022&#x2F;1&#x2F;6</h3><h4 id="go-into-one’s-shells"><a href="#go-into-one’s-shells" class="headerlink" title="go into one’s shells"></a>go into one’s shells</h4><p>变得沉默、羞怯</p>
<h4 id="⭐in-a-row"><a href="#⭐in-a-row" class="headerlink" title="⭐in a row"></a>⭐in a row</h4><p>连续地</p>
<h4 id="velocity"><a href="#velocity" class="headerlink" title="velocity"></a>velocity</h4><p>速度</p>
<h4 id="⭐face-up-to"><a href="#⭐face-up-to" class="headerlink" title="⭐face up to"></a>⭐face up to</h4><p>直面，正视（真相、事实等）</p>
<p>e.g. Facing up to reality is a key characteristic of the successful.</p>
<h4 id="boo"><a href="#boo" class="headerlink" title="boo"></a>boo</h4><p>朝···发嘘声，向···喝倒彩</p>
<h4 id="on-sb-’s-backs"><a href="#on-sb-’s-backs" class="headerlink" title="on sb.’s backs"></a>on sb.’s backs</h4><p>找某人麻烦；打扰某人</p>
<p>e.g. When the crowd were on their backs, no one wanted to try anything in case they got booed.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/31/VS%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8E%8B%E7%BC%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/31/VS%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8E%8B%E7%BC%A9/" class="post-title-link" itemprop="url">VS项目文件夹压缩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-31 11:14:15" itemprop="dateCreated datePublished" datetime="2021-12-31T11:14:15+08:00">2021-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 11:08:10" itemprop="dateModified" datetime="2024-05-01T11:08:10+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用vs2019创建项目后，对整个文件夹打包，发现压缩包远远大于文件夹大小。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>vs2019创建项目后会生成一个.vs文件夹，默认隐藏，很大，一般有几十MB。该文件夹用于vs2019提供各种便利和智能操作，但不会影响编译。</p>
<p>表面上项目文件夹大小不到1MB，但是算上隐藏的文件夹实际上该项目文件夹很大，压缩后出现了压缩包反而比原文件更大的假象。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在文件资源管理器&gt;查看&gt;显示&#x2F;隐藏，勾选隐藏的项目，就可以看到.vs文件夹，删除即可，如果有已经写了很多个项目，可以在最上层的文件夹甚至到硬盘根目录搜索.vs，全部选择并删除。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>其实可以更改vs2019的设置，使得所有.vs文件夹内的大部分内容存放到指定文件夹。</p>
<blockquote>
<p>[工具]—&gt;[选项]—&gt;[文本编辑器]—&gt;C&#x2F;C++]—&gt;[高级]—&gt;[回退位置]里面的三项属性值按下图进行修改，其中回退路径随便设置。</p>
<p>设置个回退路径这样可比较好管理这些庞大的臃肿的文件，可以定期清理它们，释放磁盘空间</p>
</blockquote>
<p><img src="/2021/12/31/VS%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8E%8B%E7%BC%A9/image-20211231115128406.png" alt="image-20211231115128406"></p>
<p>请参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/songyi160/article/details/51612716">(14条消息) 轻松搞定VS生成sdf和ipch文件太大占用空间问题_松一160-CSDN博客_ipch文件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/28/C-%E6%9D%82%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/C-%E6%9D%82%E8%AE%B0/" class="post-title-link" itemprop="url">C/C++杂记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 20:34:29" itemprop="dateCreated datePublished" datetime="2021-12-28T20:34:29+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:46:05" itemprop="dateModified" datetime="2024-05-01T10:46:05+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="编译期错误"><a href="#编译期错误" class="headerlink" title="编译期错误"></a>编译期错误</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>声明和定义只能有一个默认参数。</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><h4 id="合法输入"><a href="#合法输入" class="headerlink" title="合法输入"></a>合法输入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 输入验证</span></span><br><span class="line"><span class="keyword">while</span> (!(cin &gt;&gt; choice) || choice &lt; <span class="number">0</span> || choice &gt; <span class="number">11</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;内容无效，请重新输入：&quot;</span> ;</span><br><span class="line">    cin.<span class="built_in">clear</span>(); <span class="comment">// 重置流状态</span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略无效字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="暂停程序"><a href="#暂停程序" class="headerlink" title="暂停程序"></a>暂停程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停程序</span></span><br><span class="line"><span class="type">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = cin.<span class="built_in">ignore</span>().<span class="built_in">get</span>()) != <span class="string">&#x27;\n&#x27;</span>) &#123;&#125; <span class="comment">// 忽略字符，直至换行符（换行符也被忽略）</span></span><br></pre></td></tr></table></figure>



<h2 id="测试C-程序运行时间"><a href="#测试C-程序运行时间" class="headerlink" title="测试C++程序运行时间"></a>测试C++程序运行时间</h2><h2 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h2><h3 id="独立命名空间"><a href="#独立命名空间" class="headerlink" title="独立命名空间"></a>独立命名空间</h3><p>把重复的代码写成函数，在参数传递的过程中可以修改变量名字，函数内部相当于一个独立的命名空间，不同的变量以相同的名字出现，而不用纠结起名的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">100</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span> * a;</span><br><span class="line">    func(b); <span class="comment">// 这一步将实参b传给形参a，而不用起名a1、a2、</span></span><br><span class="line">    		 <span class="comment">// a3...从宏观维度命名改成从微观维度命名，</span></span><br><span class="line">    		 <span class="comment">// 只能看见a和b两个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="memmove-amp-amp-strcpy的区别"><a href="#memmove-amp-amp-strcpy的区别" class="headerlink" title="memmove &amp;&amp; strcpy的区别"></a>memmove &amp;&amp; strcpy的区别</h4><p>MIT6.S081中Lab1的find练习，有个地方不能用memmove，能用strcpy。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/26/%E8%BD%AF%E4%BB%B6Typora%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/26/%E8%BD%AF%E4%BB%B6Typora%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Typora使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-26 10:22:42" itemprop="dateCreated datePublished" datetime="2021-12-26T10:22:42+08:00">2021-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 11:20:38" itemprop="dateModified" datetime="2024-05-01T11:20:38+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="源代码模式"><a href="#源代码模式" class="headerlink" title="源代码模式"></a>源代码模式</h3><p>可以看到markdown语法，建议经常切换到该模式。</p>
<p>快捷键：Ctrl + &#x2F;</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>快捷键：---</p>
<p>例如：</p>
<hr>
<h3 id="的用法"><a href="#的用法" class="headerlink" title="\的用法"></a>\的用法</h3><p>打印特定字符，例如打印分割线的快捷键</p>
<p>---</p>
<p>，而不会变成分割线。或者打印\本身。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/26/%E5%A4%A7%E4%BA%8C%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%AF%BE%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/26/%E5%A4%A7%E4%BA%8C%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%AF%BE%E7%A8%8B/" class="post-title-link" itemprop="url">大二离散数学课程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-26 09:05:55" itemprop="dateCreated datePublished" datetime="2021-12-26T09:05:55+08:00">2021-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:55:00" itemprop="dateModified" datetime="2024-05-01T10:55:00+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学笔记"><a href="#离散数学笔记" class="headerlink" title="离散数学笔记"></a>离散数学笔记</h1><h2 id="代数结构"><a href="#代数结构" class="headerlink" title="代数结构"></a>代数结构</h2><h3 id="代数系统"><a href="#代数系统" class="headerlink" title="代数系统"></a>代数系统</h3><h3 id="群与环"><a href="#群与环" class="headerlink" title="群与环"></a>群与环</h3><h3 id="格与布尔代数"><a href="#格与布尔代数" class="headerlink" title="格与布尔代数"></a>格与布尔代数</h3><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><h3 id="欧拉图和哈密顿图"><a href="#欧拉图和哈密顿图" class="headerlink" title="欧拉图和哈密顿图"></a>欧拉图和哈密顿图</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>定义：连通无回路的子图。</p>
<h4 id="树枝"><a href="#树枝" class="headerlink" title="树枝"></a>树枝</h4><p>树的边。</p>
<h4 id="弦"><a href="#弦" class="headerlink" title="弦"></a>弦</h4><p>图中除了树枝的边。</p>
<h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><h5 id="图G的对应某条树枝的基本割集"><a href="#图G的对应某条树枝的基本割集" class="headerlink" title="图G的对应某条树枝的基本割集"></a>图G的对应某条树枝的基本割集</h5><p>该树枝和若干条弦的集合。</p>
<p>这个集合将树割成两部分，用尽可能少的弦。例如：</p>
<p>$$<br>S_1&#x3D;{e_1,e_2,e_3}<br>$$</p>
<p>$e_1$为树枝，$S_1$为该树枝对应的基本割集，$e_2、e_3$为弦。</p>
<h5 id="图G的对应某条弦的基本回路"><a href="#图G的对应某条弦的基本回路" class="headerlink" title="图G的对应某条弦的基本回路"></a>图G的对应某条弦的基本回路</h5><p>$$<br>C_1&#x3D;e_1e_2e_3<br>$$</p>
<p>$e_1为弦，C_1为e_1对应的基本回路，e_2、e_3为树枝。$</p>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>权值最小的生成树。</p>
<ul>
<li>避圈法（Kruskal算法）（从边出发，找权值最小的边，且不能产生回路）</li>
<li>Prim算法（从点出发）</li>
</ul>
<h4 id="根树及其应用"><a href="#根树及其应用" class="headerlink" title="根树及其应用"></a>根树及其应用</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ol>
<li>树根、树叶</li>
<li>内点、分支点</li>
<li>层数、树高</li>
<li>家族树、祖先、后代、父亲、儿子、兄弟</li>
<li>有序</li>
</ol>
<h5 id="树高"><a href="#树高" class="headerlink" title="树高"></a>树高</h5><p>所有顶点的最大层数。</p>
<h5 id="层数"><a href="#层数" class="headerlink" title="层数"></a>层数</h5><p>从树根到顶点v的路径的长度。</p>
<h5 id="2叉正则树"><a href="#2叉正则树" class="headerlink" title="2叉正则树"></a>2叉正则树</h5><p>除了叶子结点，其它结点均有两个孩子。</p>
<h5 id="完全2叉正则树"><a href="#完全2叉正则树" class="headerlink" title="完全2叉正则树"></a>完全2叉正则树</h5><p>叶子结点的层数都等于树高，即该树为满二叉树。</p>
<hr>
<h5 id="最优树"><a href="#最优树" class="headerlink" title="最优树"></a>最优树</h5><p>权值最小</p>
<h5 id="最优二叉树"><a href="#最优二叉树" class="headerlink" title="最优二叉树"></a>最优二叉树</h5><ul>
<li>哈夫曼算法</li>
</ul>
<h5 id="前缀、前缀码、2元前缀码、最佳前缀码"><a href="#前缀、前缀码、2元前缀码、最佳前缀码" class="headerlink" title="前缀、前缀码、2元前缀码、最佳前缀码"></a>前缀、前缀码、2元前缀码、最佳前缀码</h5><ul>
<li>哈夫曼编码</li>
</ul>
<hr>
<h3 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/19/%E5%A4%A7%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/19/%E5%A4%A7%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/" class="post-title-link" itemprop="url">大二数据结构课程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-19 12:38:44" itemprop="dateCreated datePublished" datetime="2021-12-19T12:38:44+08:00">2021-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:54:01" itemprop="dateModified" datetime="2024-05-01T10:54:01+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并查集（union-find-disjoint-sets）"><a href="#并查集（union-find-disjoint-sets）" class="headerlink" title="并查集（union-find disjoint sets）"></a>并查集（union-find disjoint sets）</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>并查集是一种树型的数据结构，用于处理一些不相交<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117">集合</a>（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p>
<p>通常使用顺序存储结构（即数组）表示，下标表示元素，对应值表示父结点的下标，用根结点表示集合，设定根结点的父结点下标为自身下标（或者-1，只要能查找根结点时进行判断就行）。</p>
<p>主要操作有初始化、查找和合并。</p>
<h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>设置n个只包含一个元素的集合，每个元素的父结点设为自身或-1。</p>
<p><code>int Parent[n];</code></p>
<p><code> for(int i=0;i&lt;n;++i)</code> </p>
<p><code> Parent[i]=i(或者-1)</code></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找元素所在的集合，即根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 寻找元素x的根结点（根结点是集合的唯一标识，即用根结点代表集合） </span></span><br><span class="line">    <span class="keyword">if</span> (Parent[x] == x)<span class="comment">//或者UFSets[x]==-1，说明x为根结点，找到集合了</span></span><br><span class="line">        <span class="keyword">return</span> x; <span class="comment">// x即为集合</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(Parent[x]); <span class="comment">// 查找父结点所在集合，即根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>将两个元素所在的集合合并为一个集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent[<span class="built_in">Find</span>(x)] = <span class="built_in">Find</span>(y); <span class="comment">// x的根结点变成y的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集的C-代码"><a href="#并查集的C-代码" class="headerlink" title="并查集的C++代码"></a>并查集的C++代码</h3><h4 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> size): <span class="built_in">unionFind_</span>(size, <span class="number">-1</span>)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unionFind_[node] == <span class="number">-1</span> ? node : <span class="built_in">find</span>(unionFind_[node]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span></span>&#123;</span><br><span class="line">        unionFind_[<span class="built_in">Find</span>(node2)] = <span class="built_in">Find</span>(node1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; unionFind_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900/">算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=aladdin#6_2">并查集_百度百科 (baidu.com)</a></p>
<h2 id="最小堆（MinHeap）"><a href="#最小堆（MinHeap）" class="headerlink" title="最小堆（MinHeap）"></a>最小堆（MinHeap）</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>最小堆是一颗完美二叉树，且满足任意结点的值小于（或等于）左、右子树的值（若左、右子树不为空，即该结点不为叶子结点）。</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>以$O(log_2n)$的时间复杂度获取最小值，比直接遍历的O(n)要快。</p>
<h3 id="最小堆代码"><a href="#最小堆代码" class="headerlink" title="最小堆代码"></a>最小堆代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    E* hp; <span class="comment">// 最小堆的顺序存储结构</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftUp</span><span class="params">(<span class="type">int</span> start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftDown</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> E&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RemoveMin</span><span class="params">(E&amp; x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用顺序存储结构表示树，若以hp[0]表示根结点，对于某结点hp[i]，其左子树为hp[2i + 1]，右子树为hp[2i + 2]。</strong></p>
<p><strong>假设当前最小堆共有m个结点，则如果 2i + 1 &gt;&#x3D; m，说明左子树为空，如果2i + 2 &gt;&#x3D; m，说明右子树为空（当然左子树这是也为空）。</strong></p>
<h3 id="主要操作-1"><a href="#主要操作-1" class="headerlink" title="主要操作"></a>主要操作</h3><h4 id="构造最小堆MinHeap"><a href="#构造最小堆MinHeap" class="headerlink" title="构造最小堆MinHeap"></a>构造最小堆MinHeap</h4><p>这一步需要申请空间，需要给出数组hp的大小，代表最大结点个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DefaultMaxNodes = <span class="number">20</span>; <span class="comment">// 默认最大结点个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxNodes; </span><br><span class="line">    E* hp = <span class="literal">nullptr</span>; <span class="comment">// 最小堆的顺序存储结构</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> maxNodes = DefaultMaxNodes):<span class="keyword">this</span>.<span class="built_in">maxNodes</span>(maxNodes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请空间并初始化。</span></span><br><span class="line">        hp = <span class="keyword">new</span> E[<span class="keyword">this</span>.maxNodes]&#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="插入Insert"><a href="#插入Insert" class="headerlink" title="插入Insert"></a>插入Insert</h4><p>思路：</p>
<ol>
<li>首先保持完美二叉树的特点，插入新的元素，前提是堆未满。</li>
<li>然后为了维持父结点比孩子小的特点，若父结点大于新结点，则进行调整，直到新结点不小于父结点或者新结点成为根结点。（向上调整SiftUp）</li>
</ol>
<p>第一步，在最后的位置插入新结点，首先要找到最后的位置。这里用的是数组，那么找到对应下标就行。假设有m个结点，那新结点的下标应该是m。故应该记录最小堆当前结点个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numNodes = <span class="number">0</span>; <span class="comment">// 当前结点数</span></span><br><span class="line">    <span class="type">int</span> maxNodes;  <span class="comment">// 最大结点数</span></span><br><span class="line">    E* hp = <span class="literal">nullptr</span>; <span class="comment">// 最小堆的顺序存储结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numNodes == maxNodes;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;E&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> E&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>()) <span class="comment">// 堆满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不插入</span></span><br><span class="line">    hp[numNodes] = item; <span class="comment">// 进行插入</span></span><br><span class="line">    <span class="comment">// 向上调整，当前结点数加1</span></span><br><span class="line">    <span class="built_in">SiftUp</span>(numNodes++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，向上调整。</p>
<h4 id="向上调整SiftUp"><a href="#向上调整SiftUp" class="headerlink" title="向上调整SiftUp"></a>向上调整SiftUp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="comment">// start为新结点的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftUp</span>(<span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">    E temp = hp[start]; <span class="comment">// 暂存</span></span><br><span class="line">    <span class="comment">// 寻找新结点的位置，满足最小堆时退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (start != <span class="number">0</span>) &#123; <span class="comment">// 新结点成为根结点时退出循环</span></span><br><span class="line">        <span class="type">int</span> p = (start - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父结点</span></span><br><span class="line">        <span class="keyword">if</span> (hp[p] &gt; temp) &#123; <span class="comment">// 父大于子，不符合最小堆，父子交换</span></span><br><span class="line">            hp[start] = hp[p]; </span><br><span class="line">            start = p; <span class="comment">// 新插入的结点的位置更新为父结点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 父小于等于子，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 找到位置</span></span><br><span class="line">    <span class="comment">// start为新结点的位置，temp为新结点的值</span></span><br><span class="line">    hp[start] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="comment">// start为新结点的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftUp</span>(<span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = (start - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父结点</span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="number">0</span> || hp[p] &lt;= hp[start]) <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E temp = hp[start]; <span class="comment">// 经典三步交换，新结点的位置变为p</span></span><br><span class="line">        hp[start] = hp[p];</span><br><span class="line">        hp[p] = temp;</span><br><span class="line">        <span class="built_in">SiftUp</span>(p); <span class="comment">// 新结点继续向上调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现2.0</span></span><br><span class="line"><span class="comment">// start为新结点的位置，temp为新结点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftUp</span>(<span class="type">int</span> start, E temp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = (start - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父结点</span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="number">0</span> || hp[p] &lt;= temp) &#123; <span class="comment">// 结束条件</span></span><br><span class="line">    	hp[start] = temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 新结点的值通过参数进行传递，直到最后才保存</span></span><br><span class="line">        hp[start] = hp[p];</span><br><span class="line">        <span class="built_in">SiftUp</span>(p, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用此方法时插入函数中的</span></span><br><span class="line">	<span class="built_in">SiftUp</span>(numNodes++);</span><br><span class="line"><span class="comment">// 语句需要修改成</span></span><br><span class="line">	<span class="built_in">SiftUp</span>(numNode, hp[numNodes]);</span><br><span class="line">	++numNodes; <span class="comment">//(不宜合并成一条语句，参数的传递不一定按顺序来，容易出错。</span></span><br></pre></td></tr></table></figure>



<h4 id="删除最小元素RemoveMin"><a href="#删除最小元素RemoveMin" class="headerlink" title="删除最小元素RemoveMin"></a>删除最小元素RemoveMin</h4><p>思路：</p>
<ol>
<li>判断最小堆是否为空，空则返回0。</li>
<li>不空，保存最小值，通过引用的方式。</li>
<li>根结点（最小值）与最后一个结点hp[numNodes - 1]的值进行交换，并删除最后一个结点（即结点数-1）。</li>
<li>因为进行了交换，不一定满足最小堆性质，需要向下调整根结点SiftDown。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除最小元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;E&gt;::<span class="built_in">RemoveMin</span>(E&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) <span class="comment">// 判堆空否</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空，删除失败</span></span><br><span class="line">    <span class="comment">// 不空</span></span><br><span class="line">    x = hp[<span class="number">0</span>]; <span class="comment">// 保存最小值</span></span><br><span class="line">    h[<span class="number">0</span>] = h[--numNodes]; <span class="comment">// 交换并删除（因为要删除，所以不用完全交换）</span></span><br><span class="line">    <span class="built_in">SiftDown</span>(<span class="number">0</span>, numNodes - <span class="number">1</span>); <span class="comment">// 向下调整，要调整的结点下标为0，直到最后一个结点的下标numNodes - 1。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;E&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123; <span class="keyword">return</span> numNodes == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="向下调整SiftDown"><a href="#向下调整SiftDown" class="headerlink" title="向下调整SiftDown"></a>向下调整SiftDown</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftDown</span>(<span class="type">int</span> start, <span class="type">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">	minChild = <span class="number">2</span> * start + <span class="number">1</span>; <span class="comment">// 值小的孩子，初始化为左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (minChild &gt; end) <span class="comment">// 如果大于最后一个结点的下标，则孩子不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子存在，找到最小的孩子</span></span><br><span class="line">    <span class="keyword">if</span> (minChild + <span class="number">1</span> &lt;= end &amp;&amp; hp[minChild] &gt; hp[minChild + <span class="number">1</span>])</span><br><span class="line">        <span class="comment">// 右孩子存在且小于左孩子</span></span><br><span class="line">        ++minChild; <span class="comment">// 小孩子是右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (hp[start] &lt;= hp[minChild]) <span class="comment">// 该结点不大于两个孩子</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 符合最小堆，返回</span></span><br><span class="line">    <span class="comment">// 和小孩子交换，继续向下调整</span></span><br><span class="line">    E temp = hp[start]; <span class="comment">// 经典三步交换</span></span><br><span class="line">    hp[start] = hp[minChild];</span><br><span class="line">    hp[minChild] = temp;</span><br><span class="line">    <span class="built_in">SiftDown</span>(minChild, end); <span class="comment">// 继续向下调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULTMAXNODES</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DefaultMaxNodes = <span class="number">20</span>; <span class="comment">// 默认最大结点个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULTMAXNODES</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DEFAULTMAXNODES</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numNodes = <span class="number">0</span>; <span class="comment">// 当前结点数</span></span><br><span class="line">    <span class="type">int</span> maxNodes = <span class="number">0</span>;  <span class="comment">// 最大结点数</span></span><br><span class="line">    E* hp = <span class="literal">nullptr</span>; <span class="comment">// 最小堆的顺序存储结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numNodes == maxNodes;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> numNodes == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftUp</span><span class="params">(<span class="type">int</span> start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftDown</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> E&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RemoveMin</span><span class="params">(E&amp; x)</span></span>;</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> maxNodes = DefaultMaxNodes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxNodes = (maxNodes &gt; DefaultMaxNode) ? </span><br><span class="line">            maxNodes : DefaultMaxNode;</span><br><span class="line">        <span class="comment">// 申请空间并初始化。</span></span><br><span class="line">        hp = <span class="keyword">new</span> E[<span class="keyword">this</span>-&gt;maxNodes]&#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;E&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> E&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>()) <span class="comment">// 堆满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不插入</span></span><br><span class="line">    hp[numNodes] = item; <span class="comment">// 进行插入</span></span><br><span class="line">    <span class="comment">// 向上调整，当前结点数加1</span></span><br><span class="line">    <span class="built_in">SiftUp</span>(numNodes++);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="comment">// start为新结点的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftUp</span>(<span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">    E temp = hp[start]; <span class="comment">// 暂存</span></span><br><span class="line">    <span class="comment">// 寻找新结点的位置，满足最小堆时退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (start != <span class="number">0</span>) &#123; <span class="comment">// 新结点成为根结点时退出循环</span></span><br><span class="line">        <span class="type">int</span> p = (start - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父结点</span></span><br><span class="line">        <span class="keyword">if</span> (hp[p] &gt; temp) &#123; <span class="comment">// 父大于子，不符合最小堆，父子交换</span></span><br><span class="line">            hp[start] = hp[p]; </span><br><span class="line">            start = p; <span class="comment">// 新插入的结点的位置更新为父结点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 父小于等于子，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 找到位置</span></span><br><span class="line">    <span class="comment">// start为新结点的位置，temp为新结点的值</span></span><br><span class="line">    hp[start] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除最小元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;E&gt;::<span class="built_in">RemoveMin</span>(E&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) <span class="comment">// 判堆空否</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空，删除失败</span></span><br><span class="line">    <span class="comment">// 不空</span></span><br><span class="line">    x = hp[<span class="number">0</span>]; <span class="comment">// 保存最小值</span></span><br><span class="line">    hp[<span class="number">0</span>] = hp[--numNodes]; <span class="comment">// 交换并删除（因为要删除，所以不用完全交换）</span></span><br><span class="line">    <span class="built_in">SiftDown</span>(<span class="number">0</span>, numNodes - <span class="number">1</span>); <span class="comment">// 向下调整，要调整的结点下标为0，直到最后一个结点的下标numNodes - 1。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;E&gt;::<span class="built_in">SiftDown</span>(<span class="type">int</span> start, <span class="type">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> minChild = <span class="number">2</span> * start + <span class="number">1</span>; <span class="comment">// 值小的孩子，初始化为左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (minChild &gt; end) <span class="comment">// 如果大于最后一个结点的下标，则孩子不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子存在，找到最小的孩子</span></span><br><span class="line">    <span class="keyword">if</span> (minChild + <span class="number">1</span> &lt;= end &amp;&amp; hp[minChild] &gt; hp[minChild + <span class="number">1</span>])</span><br><span class="line">        <span class="comment">// 右孩子存在且小于左孩子</span></span><br><span class="line">        ++minChild; <span class="comment">// 小孩子是右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (hp[start] &lt;= hp[minChild]) <span class="comment">// 该结点不大于两个孩子</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 符合最小堆，返回</span></span><br><span class="line">    <span class="comment">// 和小孩子交换，继续向下调整</span></span><br><span class="line">    E temp = hp[start]; <span class="comment">// 经典三步交换</span></span><br><span class="line">    hp[start] = hp[minChild];</span><br><span class="line">    hp[minChild] = temp;</span><br><span class="line">    <span class="built_in">SiftDown</span>(minChild, end); <span class="comment">// 继续向下调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最大堆（MaxHeap）"><a href="#最大堆（MaxHeap）" class="headerlink" title="最大堆（MaxHeap）"></a>最大堆（MaxHeap）</h2><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">(C) COPYRIGHT 2021 徐杰文 ALL RIGHTS RESERVED</span></span><br><span class="line"><span class="comment">@filename            :       MaxHeap.h</span></span><br><span class="line"><span class="comment">@author              :       徐杰文</span></span><br><span class="line"><span class="comment">@date                :       2021-12-28</span></span><br><span class="line"><span class="comment">@version             :       1.0</span></span><br><span class="line"><span class="comment">@brief		         :       最大堆</span></span><br><span class="line"><span class="comment">Modification History    :</span></span><br><span class="line"><span class="comment">Date            By          Version         Change Description</span></span><br><span class="line"><span class="comment">2021/12/28      徐杰文         1.0             Original</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULTMAXNODES</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DefaultMaxNodes = <span class="number">300</span>; <span class="comment">// 默认最大结点个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULTMAXNODES</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DEFAULTMAXNODES</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numNodes = <span class="number">0</span>; <span class="comment">// 当前结点数</span></span><br><span class="line">    <span class="type">int</span> maxNodes;  <span class="comment">// 最大结点数</span></span><br><span class="line">    E* hp = <span class="literal">nullptr</span>; <span class="comment">// 最大堆的顺序存储结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numNodes == maxNodes; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numNodes == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftUp</span><span class="params">(<span class="type">int</span> start)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftDown</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> E&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RemoveMax</span><span class="params">(E&amp; x)</span></span>;</span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> maxNodes = DefaultMaxNodes) :<span class="built_in">maxNodes</span>(maxNodes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxNodes = (maxNodes &gt; DefaultMaxNode) ? </span><br><span class="line">            maxNodes : DefaultMaxNode;</span><br><span class="line">        <span class="comment">// 申请空间并初始化。</span></span><br><span class="line">        hp = <span class="keyword">new</span> E[<span class="keyword">this</span>-&gt;maxNodes]&#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MaxHeap&lt;E&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> E&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>()) <span class="comment">// 堆满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不插入</span></span><br><span class="line">    hp[numNodes] = item; <span class="comment">// 进行插入</span></span><br><span class="line">    <span class="comment">// 向上调整，当前结点数加1</span></span><br><span class="line">    <span class="built_in">SiftUp</span>(numNodes++);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="comment">// start为新结点的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MaxHeap&lt;E&gt;::<span class="built_in">SiftUp</span>(<span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">    E temp = hp[start]; <span class="comment">// 暂存</span></span><br><span class="line">    <span class="comment">// 寻找新结点的位置，满足最大堆时退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (start != <span class="number">0</span>) &#123; <span class="comment">// 新结点成为根结点时退出循环</span></span><br><span class="line">        <span class="type">int</span> p = (start - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; hp[p]) &#123; <span class="comment">// 父小于子，不符合最大堆，父子交换</span></span><br><span class="line">            hp[start] = hp[p];</span><br><span class="line">            start = p; <span class="comment">// 新插入的结点的位置更新为父结点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 父大于等于子，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 找到位置</span></span><br><span class="line">    <span class="comment">// start为新结点的位置，temp为新结点的值</span></span><br><span class="line">    hp[start] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除最大元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">bool</span> MaxHeap&lt;E&gt;::<span class="built_in">RemoveMax</span>(E&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) <span class="comment">// 判堆空否</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空，删除失败</span></span><br><span class="line">    <span class="comment">// 不空</span></span><br><span class="line">    x = hp[<span class="number">0</span>]; <span class="comment">// 保存最大值</span></span><br><span class="line">    hp[<span class="number">0</span>] = hp[--numNodes]; <span class="comment">// 交换并删除（因为要删除，所以不用完全交换）</span></span><br><span class="line">    <span class="built_in">SiftDown</span>(<span class="number">0</span>, numNodes - <span class="number">1</span>); <span class="comment">// 向下调整，要调整的结点下标为0，直到最后一个结点的下标numNodes - 1。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> MaxHeap&lt;E&gt;::<span class="built_in">SiftDown</span>(<span class="type">int</span> start, <span class="type">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxChild = <span class="number">2</span> * start + <span class="number">1</span>; <span class="comment">// 值大的孩子，初始化为左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (maxChild &gt; end) <span class="comment">// 如果大于最后一个结点的下标，则孩子不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子存在，找到最大的孩子</span></span><br><span class="line">    <span class="keyword">if</span> (maxChild + <span class="number">1</span> &lt; end &amp;&amp; hp[maxChild + <span class="number">1</span>] &gt; hp[maxChild])</span><br><span class="line">        <span class="comment">// 右孩子存在且大于左孩子</span></span><br><span class="line">        ++maxChild; <span class="comment">// 大孩子是右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (hp[maxChild] &lt;= hp[start]) <span class="comment">// 该结点不小于两个孩子</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 符合最大堆，返回</span></span><br><span class="line">    <span class="comment">// 和大孩子交换，继续向下调整</span></span><br><span class="line">    E temp = hp[start]; <span class="comment">// 经典三步交换</span></span><br><span class="line">    hp[start] = hp[maxChild];</span><br><span class="line">    hp[maxChild] = temp;</span><br><span class="line">    <span class="built_in">SiftDown</span>(maxChild, end); <span class="comment">// 继续向下调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><h2 id="二叉树（BinTree）"><a href="#二叉树（BinTree）" class="headerlink" title="二叉树（BinTree）"></a>二叉树（BinTree）</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBinTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输入树根</span></span><br><span class="line">    <span class="comment">// 创建左分支，直到失败</span></span><br><span class="line">    <span class="comment">// 创建右分支，成功则进入左分支，失败，若栈空，结束；否则退栈，继续创建右分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要记录过程，实际应用可能很多问题，比如输入流出错未处理，数据结构未交待</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &quot;bintree.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bintree::CreateBinTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">if</span> (!(cin &gt;&gt; data) || data == <span class="number">-1</span>) <span class="comment">// 根为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="built_in">btnode</span>(data); <span class="comment">// 创建根</span></span><br><span class="line">    btnode *p = root;</span><br><span class="line">    stack&lt;btnode*&gt; s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; data &amp;&amp; data != <span class="number">-1</span>) &#123; <span class="comment">// 创建左分支</span></span><br><span class="line">            p-&gt;lchild = <span class="keyword">new</span> <span class="built_in">btnode</span>(data);</span><br><span class="line">            s.<span class="built_in">push</span>(p); <span class="comment">// 入栈，待创建右分支</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; data &amp;&amp; data == <span class="number">-1</span> &amp;&amp; !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); <span class="comment">// 出栈，创建右分支</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="number">-1</span>) &#123; <span class="comment">// 创建右分支</span></span><br><span class="line">            p-&gt;rchild = <span class="keyword">new</span> <span class="built_in">btnode</span>(data);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (data != <span class="number">-1</span> &amp;&amp; stack.<span class="built_in">empty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(string file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="comment">// 写入根结点</span></span><br><span class="line">    <span class="comment">// 写入左分支，直至空</span></span><br><span class="line">    <span class="comment">// 右分支为空，回退取栈，直至栈空或右分支非空。</span></span><br><span class="line">    <span class="comment">// 栈空，结束；否则写入右分支的根结点，然后进入左分支。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bintree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bintree::write</span><span class="params">(string file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(file, ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out.<span class="built_in">isopen</span>())</span><br><span class="line">    &#123; cerr &lt;&lt; <span class="string">&quot;open error!&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    btnode *p = root;</span><br><span class="line">    stack&lt;btnode*&gt; s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">0</span>) &#123; <span class="comment">// 左分支</span></span><br><span class="line">            out &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(p-&gt;rchild); <span class="comment">// 右分支</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p == <span class="number">0</span> &amp;&amp; !s.<span class="built_in">empty</span>()) &#123; <span class="comment">// 右分支</span></span><br><span class="line">            p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != <span class="number">0</span> || !s.<span class="built_in">empty</span>());</span><br><span class="line">    out.<span class="built_in">flush</span>();</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右子树非空才需要入栈；非空才访问左子树，否则直接退栈。</span></span><br><span class="line"><span class="comment">// 核心思想：访问非空子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bintree::write</span><span class="params">(string file)</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(file, ios::out)</span></span>;</span><br><span class="line">    btnode *p = root;</span><br><span class="line">    &#123; stack&lt;btnode*&gt; s; s.<span class="built_in">push</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        out &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="number">0</span>) s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="number">0</span>) p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> &#123; p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); &#125; <span class="comment">// 块语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归（前序遍历）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(ifstream&amp; in, btnode* &amp;subtree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">if</span> (!in.<span class="built_in">peek</span>() &amp;&amp; (in &gt;&gt; data) &amp;&amp; data != <span class="number">-1</span>) &#123;</span><br><span class="line">            subtree = <span class="keyword">new</span> <span class="built_in">btnode</span>(data);<span class="comment">//根</span></span><br><span class="line">            <span class="built_in">Read</span>(in, subtree-&gt;lchild);<span class="comment">//左</span></span><br><span class="line">            <span class="built_in">Read</span>(in, subtree-&gt;rchild);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/15/The-Missing-Semester-of-Your-CS-Education/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/The-Missing-Semester-of-Your-CS-Education/" class="post-title-link" itemprop="url">The Missing Semester of Your CS Education</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-15 13:07:49" itemprop="dateCreated datePublished" datetime="2021-12-15T13:07:49+08:00">2021-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 11:29:20" itemprop="dateModified" datetime="2024-05-01T11:29:20+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机教育中遗失的一课-个人笔记"><a href="#计算机教育中遗失的一课-个人笔记" class="headerlink" title="计算机教育中遗失的一课[个人笔记]"></a>计算机教育中遗失的一课[个人笔记]</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><table>
<thead>
<tr>
<th>命令&#x2F;Program</th>
<th>作用</th>
<th>备注</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir</td>
<td>创建文件夹</td>
<td>make directory</td>
<td>mkdir missing</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件或文件夹</td>
<td>remove</td>
<td>rm missing</td>
</tr>
<tr>
<td>ls</td>
<td>显示当前文件夹的内容</td>
<td></td>
<td>ls</td>
</tr>
<tr>
<td>cd</td>
<td>移动位置</td>
<td></td>
<td>cd &#x2F;home</td>
</tr>
<tr>
<td>man</td>
<td>手册</td>
<td>manual</td>
<td>man mkdir</td>
</tr>
<tr>
<td>echo</td>
<td>显示或者输入</td>
<td></td>
<td>echo hello&#x2F; world</td>
</tr>
<tr>
<td>cat</td>
<td>显示文件内容&#x2F;写入</td>
<td></td>
<td>cat (&gt; )hello.txt</td>
</tr>
<tr>
<td>chmod</td>
<td>修改模式</td>
<td>change mod</td>
<td>chmod u+r,g-w,o&#x3D;x semester</td>
</tr>
<tr>
<td>touch</td>
<td>创建文件</td>
<td></td>
<td>touch semester</td>
</tr>
</tbody></table>
<p>chmod参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-chmod.html">Linux chmod 命令 | 菜鸟教程 (runoob.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/12/14/C-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%97%B6%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E5%A4%B1%E8%B4%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/14/C-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%97%B6%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E5%A4%B1%E8%B4%A5/" class="post-title-link" itemprop="url">C++模板类继承模板类时子类访问父类失败</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-14 21:39:07" itemprop="dateCreated datePublished" datetime="2021-12-14T21:39:07+08:00">2021-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 10:46:16" itemprop="dateModified" datetime="2024-05-01T10:46:16+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>C++模板类继承模板类时子类无法直接访问父类的数据成员。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>使用this指针，如 this-&gt;maxVertices可以父类中的数据成员maxVertices。</li>
<li>使用类名限定变量所在作用域，如Graph&lt;T, E&gt;::maxVertices可以访问父类Graph&lt;T, E&gt;中的数据成员maxVertices。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/04/28/%E5%8D%9A%E7%89%A9%E5%BC%88%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/%E5%8D%9A%E7%89%A9%E5%BC%88%E5%BE%97/" class="post-title-link" itemprop="url">博物弈得</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-28 10:35:34" itemprop="dateCreated datePublished" datetime="2021-04-28T10:35:34+08:00">2021-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 11:02:41" itemprop="dateModified" datetime="2024-05-01T11:02:41+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链接分享"><a href="#链接分享" class="headerlink" title="链接分享"></a>链接分享</h2><blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4one8yALZ2C2Pv_NC9wsvQ">警觉|是什么塑造了我们的大脑</a></li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://1000charsdance.github.io/2021/04/27/%E9%AB%98%E6%95%B0%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chardance">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chardance的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/27/%E9%AB%98%E6%95%B0%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/" class="post-title-link" itemprop="url">高数不定积分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-27 13:07:53" itemprop="dateCreated datePublished" datetime="2021-04-27T13:07:53+08:00">2021-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 11:01:55" itemprop="dateModified" datetime="2024-05-01T11:01:55+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><table>
<thead>
<tr>
<th align="center">不定积分</th>
<th align="center">结果</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\iint_{D}arctan\frac{y}{x}dxdy$</td>
<td align="center">$\iint{\theta rd\theta dr}$</td>
<td align="center">$arctan{y\over x}$化成$\theta$</td>
</tr>
<tr>
<td align="center">$\int{tanx}dx$</td>
<td align="center">$-ln</td>
<td align="center">cosx</td>
</tr>
<tr>
<td align="center">$\int{cos^4\theta}d\theta$</td>
<td align="center">$\frac{3}{8}x+\frac{sin2x}{4}+\frac{sin4x}{32}+C$</td>
<td align="center">降次</td>
</tr>
<tr>
<td align="center">$\int{xsinxdx }$</td>
<td align="center">$sinx-xcosx$</td>
<td align="center">$\int{xsinxdx }&#x3D;-\int{xdcosx}$</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chardance</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chardance</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":183,"height":366,"scale":1,"hOffset":60,"vOffset":-28},"mobile":{"show":true,"scale":1,"hOffset":75,"vOffset":-26,"opacity":0.83},"dialog":{"enable":false,"hitokoto":true},"react":{"opacity":0.83},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
